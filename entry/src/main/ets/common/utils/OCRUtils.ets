import { textRecognition } from '@kit.CoreVisionKit'; // OCR èƒ½åŠ›
import { image } from '@kit.ImageKit'; // å›¾ç‰‡å¤„ç†
import fs from '@ohos.file.fs'; // æ–‡ä»¶ç³»ç»Ÿ
import { CloudOCRUtils } from './CloudOCRUtils';
import { pdfService } from '@kit.PDFKit';

export class OCRUtils {

  /**
   * è¯†åˆ«å›¾ç‰‡ (å¤–éƒ¨è°ƒç”¨)
   */
  static async recognizeText(imageUri: string): Promise<string> {
    if (!imageUri) return "æœªé€‰æ‹©å›¾ç‰‡";

    try {
      // ğŸŸ¢ 1. ç¬¬ä¸€å°è¯•ï¼šæœ¬åœ° CoreVisionKit è¯†åˆ« (çœŸæœºè¶…å¿«ï¼Œä¸è´¹æµé‡)
      const pixelMap = await OCRUtils.getPixelMapByUri(imageUri);

      if (pixelMap) {
        // è°ƒç”¨æœ¬åœ°è¯†åˆ«é€»è¾‘
        const localResult = await OCRUtils._recognizePixelMap(pixelMap);

        // å¦‚æœè¯†åˆ«åˆ°äº†å†…å®¹ï¼Œç›´æ¥è¿”å›ï¼Œæµç¨‹ç»“æŸ
        if (localResult && localResult.length > 0) {
          return localResult;
        }
      }

      // å¦‚æœ pixelMap ä¸ºç©ºï¼Œæˆ–è€…æœ¬åœ°è¯†åˆ«ç»“æœä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆæ¨¡æ‹Ÿå™¨å¸¸è§æƒ…å†µï¼‰ï¼Œ
      // æ‰‹åŠ¨æŠ›å‡ºä¸€ä¸ªé”™è¯¯ï¼Œå¼ºè¡Œè·³è½¬åˆ° catch å—
      throw new Error("æœ¬åœ° OCR å¼•æ“æœªè¿”å›ç»“æœ");

    } catch (e) {
      // ğŸŸ¡ 2. é™çº§å¤„ç†ï¼šæ•è·æœ¬åœ°å¤±è´¥å¼‚å¸¸ï¼Œè½¬ä¸ºäº‘ç«¯è¯†åˆ« (æ¨¡æ‹Ÿå™¨å…œåº•)
      console.warn(`æœ¬åœ°è¯†åˆ«ä¸å¯ç”¨: ${JSON.stringify(e)}`);
      console.info('æ­£åœ¨åˆ‡æ¢è‡³ç™¾åº¦äº‘è¯†åˆ«...');

      try {
        // è°ƒç”¨äº‘ç«¯æ¥å£
        const cloudResult = await CloudOCRUtils.recognizeTable(imageUri);
        return cloudResult;
      } catch (cloudError) {
        // ğŸ”´ 3. ç»ˆæå…œåº•ï¼šäº‘ç«¯ä¹ŸæŒ‚äº†
        console.error('äº‘ç«¯è¯†åˆ«å¤±è´¥:', JSON.stringify(cloudError));
        return "è¯†åˆ«å¤±è´¥ï¼šæœ¬åœ°å¼•æ“ä¸å¯ç”¨ä¸”äº‘ç«¯è¿æ¥è¶…æ—¶";
      }
    }
  }

  /**
   * çœŸå®å®ç°ï¼šè¯†åˆ« PDF (å¤–éƒ¨è°ƒç”¨)
   * æ€è·¯ï¼šæ‰“å¼€PDF -> éå†æ‰€æœ‰é¡µ -> æ¯é¡µè½¬ä¸ºå›¾ç‰‡ -> OCRè¯†åˆ« -> æ‹¼æ¥ç»“æœ
   */
  // entry/src/main/ets/common/OCRUtils.ets

  static async recognizePdf(pdfUri: string): Promise<string> {
    if (!pdfUri) return "æœªé€‰æ‹© PDF æ–‡ä»¶";

    let document: pdfService.PdfDocument | undefined;

    try {
      // ğŸ” 1.ã€ç¯å¢ƒæ£€æŸ¥ã€‘æ¨¡æ‹Ÿå™¨æ²¡æœ‰ pdfServiceï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯è¿›å…¥ catch èµ°äº‘ç«¯
      if (!canIUse("SystemCapability.OfficeService.PDFService.Core")) {
        throw new Error("å½“å‰è®¾å¤‡ä¸æ”¯æŒ PDF èƒ½åŠ› (å¯èƒ½æ˜¯æ¨¡æ‹Ÿå™¨)");
      }

      // ğŸ” 2.ã€æœ¬åœ°è¯†åˆ«æµç¨‹ã€‘(çœŸæœºèµ°è¿™é‡Œ)
      document = new pdfService.PdfDocument();
      await document.loadDocument(pdfUri);

      const pageCount = document.getPageCount();
      if (pageCount === 0) return "PDF æ–‡ä»¶ä¸ºç©º";

      let fullResult = "";
      const maxPages = Math.min(pageCount, 5);

      for (let i = 0; i < maxPages; i++) {
        const page = document.getPage(i);
        const width = page.getWidth();
        const height = page.getHeight();

        // åˆ›å»º buffer
        const bufferSize = width * height * 4;
        const buffer = new ArrayBuffer(bufferSize);

        // åˆ›å»º PixelMap
        const pixelMap = await image.createPixelMap(buffer, {
          size: { width: width, height: height },
          pixelFormat: image.PixelMapFormat.RGBA_8888,
          editable: true
        });

        // æ¸²æŸ“é¡µé¢ (ä½¿ç”¨ ESObject ç»•è¿‡ç±»å‹æ£€æŸ¥)
        await (page as ESObject).render(pixelMap);

        // OCR è¯†åˆ«
        const pageText = await OCRUtils._recognizePixelMap(pixelMap);
        fullResult += `ã€ç¬¬ ${i + 1} é¡µã€‘\n${pageText}\n\n`;

        await pixelMap.release();
      }

      return fullResult || "æœªè¯†åˆ«åˆ°æ–‡å­—";

    } catch (e) {
      // =======================================================
      // ğŸ”¥ 3.ã€é™çº§å¤„ç†ã€‘æœ¬åœ°å¤±è´¥ï¼ˆæˆ–æ¨¡æ‹Ÿå™¨ï¼‰ï¼Œè‡ªåŠ¨åˆ‡æ¢äº‘ç«¯
      // =======================================================
      console.warn(`æœ¬åœ° PDF è¯†åˆ«ä¸å¯ç”¨: ${JSON.stringify(e)}`);
      console.info('æ­£åœ¨åˆ‡æ¢è‡³äº‘ç«¯ PDF è¯†åˆ«...');

      try {
        // è°ƒç”¨ CloudOCRUtils å‘é€ç»™ç™¾åº¦äº‘
        const cloudResult = await CloudOCRUtils.recognizePdf(pdfUri);

        // å¦‚æœäº‘ç«¯è¿”å›åŒ…å«â€œå¤±è´¥â€æˆ–â€œæŠ¥é”™â€çš„å­—æ ·ï¼Œè¯´æ˜äº‘ç«¯ä¹Ÿä¸è¡Œ
        if (cloudResult.includes("å¤±è´¥") || cloudResult.includes("å¼‚å¸¸")) {
          // è¿™é‡Œå¯ä»¥è¿”å›ä¸€ä¸ª mock æ•°æ®å…œåº•ï¼Œæˆ–è€…ç›´æ¥è¿”å›é”™è¯¯ä¿¡æ¯
          return cloudResult;
        }

        return cloudResult;

      } catch (cloudError) {
        console.error('äº‘ç«¯è¯†åˆ«ä¹ŸæŒ‚äº†:', JSON.stringify(cloudError));
        return `PDF è¯†åˆ«å½»åº•å¤±è´¥: è¯·æ£€æŸ¥ç½‘ç»œæˆ–çœŸæœºç¯å¢ƒã€‚`;
      }

    } finally {
      // èµ„æºé‡Šæ”¾
      if (document) {
        // document.destroy();
      }
    }
  }

  /**
   * ğŸ”’ ç§æœ‰æ ¸å¿ƒæ–¹æ³•ï¼šä¼ å…¥ PixelMapï¼Œè¿”å›è¯†åˆ«æ–‡å­—
   * (å›¾ç‰‡å’Œ PDF æœ€ç»ˆéƒ½èµ°è¿™é‡Œ)
   */
  private static async _recognizePixelMap(pixelMap: image.PixelMap): Promise<string> {
    try {
      const visionInfo: textRecognition.VisionInfo = {
        pixelMap: pixelMap
      };

      // è°ƒç”¨ CoreVisionKit
      const response = await textRecognition.recognizeText(visionInfo);

      // ç®€å•å¤„ç†ï¼šå¦‚æœè¯†åˆ«ç»“æœä¸ºç©º
      if (!response.value) return "";

      return response.value;
    } catch (e) {
      console.warn('CoreVisionKit è°ƒç”¨å¤±è´¥:', e);
      return "";
    }
  }

  /**
   * è¾…åŠ©ï¼šURI è½¬ PixelMap
   */
  private static async getPixelMapByUri(uri: string): Promise<image.PixelMap | undefined> {
    let file: fs.File | undefined;
    try {
      file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
      const imageSource = image.createImageSource(file.fd);
      return await imageSource.createPixelMap();
    } catch (err) {
      return undefined;
    } finally {
      if (file) fs.closeSync(file);
    }
  }
}