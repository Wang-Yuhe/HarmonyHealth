import { textRecognition } from '@kit.CoreVisionKit'; // OCR èƒ½åŠ›
import { image } from '@kit.ImageKit'; // å›¾ç‰‡å¤„ç†
import fs from '@ohos.file.fs'; // æ–‡ä»¶ç³»ç»Ÿ
import { pdfService } from '@kit.PDFKit';

export class OCRUtils {

  /**
   * è¯†åˆ«å›¾ç‰‡ (å¤–éƒ¨è°ƒç”¨)
   */
  static async recognizeText(imageUri: string): Promise<string> {
    if (!imageUri) return "æœªé€‰æ‹©å›¾ç‰‡";
    try {
      const pixelMap = await OCRUtils.getPixelMapByUri(imageUri);
      if (!pixelMap) return "å›¾ç‰‡è§£æå¤±è´¥";
      return await OCRUtils._recognizePixelMap(pixelMap);
    } catch (e) {
      console.error('å›¾ç‰‡è¯†åˆ«å¤±è´¥:', e);
      return "è¯†åˆ«å‡ºé”™";
    }
  }

  /**
   * çœŸå®å®ç°ï¼šè¯†åˆ« PDF (å¤–éƒ¨è°ƒç”¨)
   * æ€è·¯ï¼šæ‰“å¼€PDF -> éå†æ‰€æœ‰é¡µ -> æ¯é¡µè½¬ä¸ºå›¾ç‰‡ -> OCRè¯†åˆ« -> æ‹¼æ¥ç»“æœ
   */
  // entry/src/main/ets/common/OCRUtils.ets

  static async recognizePdf(pdfUri: string): Promise<string> {
    if (!pdfUri) return "æœªé€‰æ‹© PDF æ–‡ä»¶";

    let document: pdfService.PdfDocument | undefined;

    try {
      // 1. ä¸éœ€è¦ fs.openSync äº†ï¼Œç›´æ¥åˆ›å»ºæ–‡æ¡£å¯¹è±¡
      document = new pdfService.PdfDocument();

      // 2. ç›´æ¥ä¼ å…¥ pdfUri å­—ç¬¦ä¸²
      // API æ–‡æ¡£è¦æ±‚ï¼šloadDocument(uri: string, password?: string)
      await document.loadDocument(pdfUri);

      const pageCount = document.getPageCount();
      if (pageCount === 0) return "PDF æ–‡ä»¶ä¸ºç©º";

      let fullResult = "";
      const maxPages = Math.min(pageCount, 5); // é™åˆ¶é¡µæ•°é˜²æ­¢å¡é¡¿

      for (let i = 0; i < maxPages; i++) {
        // è·å–é¡µé¢
        const page = document.getPage(i);

        // åˆ›å»ºä½å›¾
        const width = page.getWidth();
        const height = page.getHeight();

        // æ³¨æ„ï¼šAPI 11+ ä¸­ createPixelMap çš„å‚æ•°å¯èƒ½éœ€è¦æ ¹æ®æœ€æ–°æ–‡æ¡£è°ƒæ•´
        // è¿™é‡Œå‡è®¾ä½¿ç”¨æ ‡å‡† ImageKit åˆ›å»ºæ–¹æ³•
        // 1. è®¡ç®—ç¼“å†²åŒºå¤§å°
        // RGBA_8888 æ ¼å¼æ¯ä¸ªåƒç´ å ç”¨ 4 ä¸ªå­—èŠ‚
        const bufferSize = width * height * 4;

        // 2. åˆ›å»ºä¸€ä¸ªç©ºçš„ ArrayBuffer (å…¨ 0ï¼Œå³é€æ˜/é»‘è‰²èƒŒæ™¯)
        const buffer = new ArrayBuffer(bufferSize);

        // 3. ä¼ å…¥ buffer å’Œ é€‰é¡¹
        const pixelMap = await image.createPixelMap(buffer, {
          size: { width: width, height: height },
          pixelFormat: image.PixelMapFormat.RGBA_8888,
          editable: true // å…è®¸ PDF æ¸²æŸ“å†™å…¥
        });

        // æ¸²æŸ“é¡µé¢
        await (page as ESObject).render(pixelMap);

        // OCR è¯†åˆ«
        const pageText = await OCRUtils._recognizePixelMap(pixelMap);
        fullResult += `ã€ç¬¬ ${i + 1} é¡µã€‘\n${pageText}\n\n`;

        // é‡Šæ”¾å†…å­˜
        await pixelMap.release();
      }

      return fullResult || "æœªè¯†åˆ«åˆ°æ–‡å­—";

    } catch (e) {
      console.error('PDF è¯†åˆ«å¼‚å¸¸:', JSON.stringify(e));
      return `PDF å¤„ç†å¤±è´¥: ${e.message}`;
    } finally {
      // 3. èµ„æºé‡Šæ”¾
      if (document) {
        // è¿™é‡Œçš„é”€æ¯æ–¹æ³•å–å†³äºå…·ä½“çš„ API ç‰ˆæœ¬ï¼Œæœ‰äº›ç‰ˆæœ¬ä¸éœ€è¦æ‰‹åŠ¨ destroy
        // è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æ£€æŸ¥ï¼Œå¦‚æœä½ çš„ SDK æç¤ºæ²¡æœ‰ destroy æ–¹æ³•ï¼Œå¯ä»¥æ³¨é‡Šæ‰ä¸‹é¢è¿™è¡Œ
        // document.destroy();
      }
      // ä¸éœ€è¦ fs.closeSync(file)ï¼Œå› ä¸ºæˆ‘ä»¬å‹æ ¹æ²¡æ‰“å¼€ file
    }
  }

  /**
   * ğŸ”’ ç§æœ‰æ ¸å¿ƒæ–¹æ³•ï¼šä¼ å…¥ PixelMapï¼Œè¿”å›è¯†åˆ«æ–‡å­—
   * (å›¾ç‰‡å’Œ PDF æœ€ç»ˆéƒ½èµ°è¿™é‡Œ)
   */
  private static async _recognizePixelMap(pixelMap: image.PixelMap): Promise<string> {
    try {
      const visionInfo: textRecognition.VisionInfo = {
        pixelMap: pixelMap
      };

      // è°ƒç”¨ CoreVisionKit
      const response = await textRecognition.recognizeText(visionInfo);

      // ç®€å•å¤„ç†ï¼šå¦‚æœè¯†åˆ«ç»“æœä¸ºç©º
      if (!response.value) return "";

      return response.value;
    } catch (e) {
      console.warn('CoreVisionKit è°ƒç”¨å¤±è´¥:', e);
      return "";
    }
  }

  /**
   * è¾…åŠ©ï¼šURI è½¬ PixelMap
   */
  private static async getPixelMapByUri(uri: string): Promise<image.PixelMap | undefined> {
    let file: fs.File | undefined;
    try {
      file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
      const imageSource = image.createImageSource(file.fd);
      return await imageSource.createPixelMap();
    } catch (err) {
      return undefined;
    } finally {
      if (file) fs.closeSync(file);
    }
  }
}