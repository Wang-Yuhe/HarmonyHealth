import { http } from '@kit.NetworkKit';
import { util } from '@kit.ArkTS';
import fs from '@ohos.file.fs';

// ==========================================
// 1. å®šä¹‰å®Œæ•´çš„æ¥å£ç»“æ„ (å…³é”®ï¼)
// ==========================================

// åæ ‡ä¿¡æ¯ (ç™¾åº¦è¿”å›çš„ location)
interface LocationInfo {
  top: number;
  left: number;
  width: number;
  height: number;
}

// OCR ç»“æœé¡¹ (åŒ…å«æ–‡å­—å’Œåæ ‡)
interface OCRResultItem {
  words: string;
  location?: LocationInfo; // åŠ ä¸Š ? é˜²æ­¢æŸäº›ç‰¹æ®Šæƒ…å†µæ²¡æœ‰åæ ‡
}

// ç™¾åº¦ API å“åº”ç»“æ„
interface GeneralOCRResponse {
  words_result?: OCRResultItem[];
  words_result_num?: number;
  error_code?: number;
  error_msg?: string;
}

interface BaiduTokenResponse {
  access_token: string;
}

export class CloudOCRUtils {
  private static readonly API_KEY = 'Qbkvfdg8ukceY7BjweBjrbt6';
  private static readonly SECRET_KEY = 'HkN7DDAn2oM33WsziSGJpjXR1aGYCn4p';

  /**
   * å›¾ç‰‡è¯†åˆ«å…¥å£
   */
  static async recognizeTable(imageUri: string): Promise<string> {
    try {
      const token = await CloudOCRUtils.getAccessToken();
      if (!token) return "ERROR:Token è·å–å¤±è´¥";
      const base64Img = await CloudOCRUtils.imageToBase64(imageUri);
      return await CloudOCRUtils.sendAccurateRequest(token, base64Img);
    } catch (e) {
      console.error('å›¾ç‰‡è¯†åˆ«å¼‚å¸¸:', JSON.stringify(e));
      return "ERROR:è¯†åˆ«å¼‚å¸¸";
    }
  }

  /**
   * PDF è¯†åˆ«å…¥å£ (æ”¯æŒå¤šé¡µ)
   */
  static async recognizePdf(pdfUri: string): Promise<string> {
    try {
      const token = await CloudOCRUtils.getAccessToken();
      if (!token) return "ERROR:Token è·å–å¤±è´¥";

      const base64Pdf = await CloudOCRUtils.fileToBase64(pdfUri);
      let fullResult = "";
      const MAX_PAGES = 5;

      for (let page = 1; page <= MAX_PAGES; page++) {
        const pageResult = await CloudOCRUtils.sendAccurateRequest(token, base64Pdf, true, page);

        if (pageResult.includes("ç™¾åº¦æŠ¥é”™") || pageResult.includes("æ¥å£è¯·æ±‚å¤±è´¥")) {
          if (page === 1) return pageResult;
          break;
        }
        fullResult += `\nã€ç¬¬ ${page} é¡µã€‘\n------------------\n` + pageResult + "\n";
      }
      return fullResult || "ERROR:PDF æœªè¯†åˆ«åˆ°å†…å®¹";
    } catch (e) {
      console.error('PDFè¯†åˆ«å¼‚å¸¸:', JSON.stringify(e));
      return "ERROR:PDF è¯†åˆ«å¤±è´¥";
    }
  }

  /**
   * å‘é€è¯·æ±‚ (é«˜ç²¾åº¦æ¥å£)
   */
  private static async sendAccurateRequest(token: string, base64Data: string, isPdf: boolean = false, pageNum: number = 1): Promise<string> {
    const url = `https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=${token}`;
    const req = http.createHttp();

    // paragraph=true: å°è¯•æŒ‰æ®µè½æ•´ç†ï¼Œå‡å°‘ç¢ç‰‡
    // vertexes_location=true: (å¯é€‰) è·å–æ›´è¯¦ç»†åæ ‡ï¼Œæ™®é€š location å°±å¤Ÿç”¨äº†
    let body = `detect_direction=true&vertexes_location=true&`;
    if (isPdf) {
      body += `pdf_file=${encodeURIComponent(base64Data)}&pdf_file_num=${pageNum}`;
    } else {
      body += `image=${encodeURIComponent(base64Data)}`;
    }

    try {
      const response = await req.request(url, {
        method: http.RequestMethod.POST,
        header: { 'Content-Type': 'application/x-www-form-urlencoded' },
        extraData: body,
        connectTimeout: 30000,
        readTimeout: 30000
      });

      if (response.responseCode === 200) {
        const res = JSON.parse(response.result as string) as GeneralOCRResponse;

        if (res.error_code) {
          return `ERROR:ç™¾åº¦æŠ¥é”™: ${res.error_msg} (Code: ${res.error_code})`;
        }

        if (res.words_result) {
          // ğŸ”¥ æ‰“å°æ—¥å¿—ï¼Œç¡®è®¤æ˜¯å¦æ‹¿åˆ°äº†æ•°æ®
          console.info(`[OCR Debug] æ‹¿åˆ° ${res.words_result.length} è¡Œæ–‡å­—`);

          // è°ƒç”¨æ’ç‰ˆç®—æ³•
          return CloudOCRUtils.formatSmartLayout(res.words_result);
        }
      }
      return `ERROR:æ¥å£è¯·æ±‚å¤±è´¥: ${response.responseCode}`;
    } catch (e) {
      console.error('ç½‘ç»œè¯·æ±‚å‡ºé”™:', JSON.stringify(e));
      return "ERROR:ç½‘ç»œè¯·æ±‚å‡ºé”™";
    }
  }

  /**
   * ğŸ”¥ğŸ”¥ğŸ”¥ã€æ ¸å¿ƒæ’ç‰ˆç®—æ³•ã€‘(ä¿®å¤ç‰ˆ)
   * åŒ…å«â€œè‡ªåŠ¨é™çº§â€é€»è¾‘ï¼Œé˜²æ­¢ç™½å±
   */
  private static formatSmartLayout(items: OCRResultItem[]): string {
    if (!items || items.length === 0) return "";

    // 1. å®šä¹‰è¡Œé«˜å®¹å·® (åƒç´ )
    // å¦‚æœä¸¤ä¸ªæ–‡å­—å—çš„é«˜åº¦å·®å°äºè¿™ä¸ªå€¼ (æ¯”å¦‚ 15px)ï¼Œå°±è®¤ä¸ºå®ƒä»¬åœ¨åŒä¸€è¡Œ
    const Y_TOLERANCE = 15;

    // 2. å…ˆæŒ‰ Top (Yè½´) ä»ä¸Šåˆ°ä¸‹ç²—ç•¥æ’åº
    // æ³¨æ„ï¼šåŠ ä¸Š ?. å’Œ || 0 é˜²æ­¢å´©æºƒ
    items.sort((a, b) => (a.location?.top || 0) - (b.location?.top || 0));

    // 3. å¼€å§‹åˆ†ç»„ (æŠŠåŒä¸€è¡Œçš„å½’åˆ°ä¸€èµ·)
    let rows: OCRResultItem[][] = [];
    let currentRow: OCRResultItem[] = [];
    let currentY = -999;

    for (let item of items) {
      const currentTop = item.location?.top || 0;

      // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªï¼Œæˆ–è€…ä¸å½“å‰è¡Œçš„é«˜åº¦å·®è¶…è¿‡äº†å®¹å·® -> å¼€å¯æ–°çš„ä¸€è¡Œ
      if (currentY === -999 || Math.abs(currentTop - currentY) > Y_TOLERANCE) {
        if (currentRow.length > 0) {
          rows.push(currentRow);
        }
        currentRow = [item];
        currentY = currentTop; // æ›´æ–°å½“å‰è¡Œçš„åŸºå‡†é«˜åº¦
      } else {
        // å¦åˆ™ï¼Œè®¤ä¸ºæ˜¯åŒä¸€è¡Œï¼ŒåŠ å…¥å½“å‰è¡Œ
        currentRow.push(item);
      }
    }
    // åŠ å…¥æœ€åä¸€è¡Œ
    if (currentRow.length > 0) rows.push(currentRow);

    // 4. æ‹¼æ¥æœ€ç»ˆæ–‡æœ¬
    let finalString = "";

    for (let row of rows) {
      // 4.1 è¡Œå†…æ’åºï¼šæŒ‰ Left (Xè½´) ä»å·¦åˆ°å³æ’ï¼Œé˜²æ­¢å·¦å³é¢ å€’
      row.sort((a, b) => (a.location?.left || 0) - (b.location?.left || 0));

      let lineText = "";

      // 4.2 æ™ºèƒ½æ‹¼æ¥è¡Œå†…å…ƒç´ 
      for (let i = 0; i < row.length; i++) {
        const item = row[i];
        let words = item.words.trim();

        // (å¯é€‰) ç»†èŠ‚ä¼˜åŒ–ï¼šç»™ä¸­æ–‡å’Œæ•°å­—ä¹‹é—´åŠ ç©ºæ ¼
        words = words.replace(/([\u4e00-\u9fa5])([0-9a-zA-Z])/g, '$1 $2');
        words = words.replace(/([0-9a-zA-Z])([\u4e00-\u9fa5])/g, '$1 $2');

        if (i > 0) {
          // è®¡ç®—å½“å‰å—å’Œå‰ä¸€ä¸ªå—çš„è·ç¦»
          const prev = row[i-1];
          const prevRight = (prev.location?.left || 0) + (prev.location?.width || 0);
          const currentLeft = item.location?.left || 0;
          const distance = currentLeft - prevRight;

          // å¦‚æœè·ç¦»æ¯”è¾ƒè¿œï¼ŒåŠ å¤šå‡ ä¸ªç©ºæ ¼æ¨¡æ‹Ÿæ’ç‰ˆ
          const spaces = distance > 50 ? "    " : "  ";

          // å¦‚æœè¿™ä¸€è¡Œçœ‹èµ·æ¥åƒè¡¨æ ¼æ•°æ®ï¼ˆåŒ…å«æ•°å­—ï¼‰ï¼Œå¯ä»¥ç”¨ç«–çº¿åˆ†éš”
          //if (/\d/.test(words)) {
          //  lineText += " | " + words;
          //} else {
            lineText += spaces + words;
          //}
        } else {
          // ç¬¬ä¸€ä¸ªå…ƒç´ 
          lineText += words;
        }
      }

      // ğŸ”¥ å¼ºåˆ¶æ¢è¡Œï¼šå¤„ç†å®Œä¸€è¡Œ visual row åï¼ŒåŠ ä¸Š \n
      finalString += lineText + "\n";

      // 4.3 è¯†åˆ«åˆ°è¡¨å¤´ï¼ŒåŠ ä¸ªåˆ†å‰²çº¿è£…è£…æ ·å­
      if (lineText.includes("é¡¹ç›®") && lineText.includes("ç»“æœ")) {
        finalString += "----------------------------------------\n";
      }
    }

    return finalString;
  }

  // ================= è¾…åŠ©æ–¹æ³• =================
  private static async getAccessToken(): Promise<string> {
    const url = `https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=${CloudOCRUtils.API_KEY}&client_secret=${CloudOCRUtils.SECRET_KEY}`;
    const req = http.createHttp();
    const response = await req.request(url, { method: http.RequestMethod.POST });
    if (response.responseCode === 200) {
      const result = JSON.parse(response.result as string) as BaiduTokenResponse;
      return result.access_token;
    }
    return "";
  }

  private static async imageToBase64(uri: string): Promise<string> {
    try {
      let file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
      let stat = fs.statSync(file.fd);
      let buffer = new ArrayBuffer(stat.size);
      fs.readSync(file.fd, buffer);
      fs.closeSync(file);
      let helper = new util.Base64Helper();
      let u8Arr = new Uint8Array(buffer);
      return helper.encodeToStringSync(u8Arr);
    } catch (e) {
      return "";
    }
  }

  private static async fileToBase64(uri: string): Promise<string> {
    try {
      let file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
      let stat = fs.statSync(file.fd);
      if (stat.size > 4 * 1024 * 1024) {
        fs.closeSync(file);
        throw new Error("æ–‡ä»¶è¿‡å¤§");
      }
      let buffer = new ArrayBuffer(stat.size);
      fs.readSync(file.fd, buffer);
      fs.closeSync(file);
      let helper = new util.Base64Helper();
      let u8Arr = new Uint8Array(buffer);
      return helper.encodeToStringSync(u8Arr);
    } catch (e) {
      return "";
    }
  }
}