/**
 * @file AskAIPage.ets
 * @description AI å’¨è¯¢é¡µé¢ - UI ä¼˜åŒ–ç‰ˆ
 */
import { myNavigator } from '../common/components/Navigator';
import common from '@ohos.app.ability.common';
import dataPreferences from '@ohos.data.preferences';
import { HealthAIService } from '../features/ai/service/HealthAIService';

interface ChatMessage {
  id: number;
  from: 'user' | 'ai';
  text: string;
}

@Entry
@Component
struct AskAIPage {
  @State historySnapshot: string = '[]'
  @State messages: ChatMessage[] = []
  @State inputText: string = ''
  @State isThinking: boolean = false
  private nextId: number = 1
  private chatScroller: Scroller = new Scroller()
  private static readonly PREF_FILE: string = 'ask_ai_history'
  private static readonly HISTORY_KEY: string = 'history'
  private preferences?: dataPreferences.Preferences

  aboutToAppear() {
    this.restoreMessages()
  }

  build() {
    Stack() {
      // èƒŒæ™¯è‰²
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('#F5F7FA') // æ›´æŸ”å’Œçš„æµ…ç°èƒŒæ™¯

      Column() {
        this.HeaderSection()

        Stack({ alignContent: Alignment.Top }) {
          Column() {
            Scroll(this.chatScroller) {
              Column({ space: 16 }) { // å¢åŠ æ°”æ³¡é—´è·
                if (this.messages.length === 0) {
                  this.EmptyPlaceholder()
                } else {
                  // é¡¶éƒ¨ç•™ç™½ï¼Œé¿å…è¢«å¤´éƒ¨é®æŒ¡ï¼ˆå¦‚æœå¤´éƒ¨æ‚¬æµ®ï¼‰æˆ–å¤ªç´§å‡‘
                  Blank().height(10)

                  ForEach(this.messages, (msg: ChatMessage) => {
                    this.MessageBubble(msg)
                  }, (msg: ChatMessage) => msg.id.toString())
                }

                if (this.isThinking) {
                  this.TypingIndicator()
                }

                // åº•éƒ¨ç•™ç™½ï¼Œé˜²æ­¢è¢«è¾“å…¥æ¡†é®æŒ¡
                Blank().height(20)
              }
              .width('100%')
              .padding({ left: 16, right: 16 })
            }
            .layoutWeight(1)
            .scrollBar(BarState.Auto)
            .edgeEffect(EdgeEffect.Spring) // å¢åŠ å›å¼¹æ•ˆæœ
          }
          .width('100%')
          .height('100%')

          // æ‚¬æµ®çš„æ–°å»ºå¯¹è¯æŒ‰é’®
          this.FloatingToolbar()
        }
        .layoutWeight(1)
        .width('100%')
        .backgroundColor('#F5F7FA')

        this.InputArea()
      }
      .width('100%')
      .height('100%')
      // é¿å¼€åº•éƒ¨å¯¼èˆªæ é«˜åº¦
      .padding({ bottom: 60 })

      myNavigator()
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  private HeaderSection() {
    Column() {
      Row() {
        Column({ space: 6 }) {
          Text('AI æ™ºèƒ½é—®è¯Š')
            .fontSize(26)
            .fontColor('#FFFFFF')
            .fontWeight(FontWeight.Bold)
          Text('æ‚¨çš„ 24 å°æ—¶ä¸“å±å¥åº·é¡¾é—®')
            .fontSize(14)
            .fontColor('rgba(255,255,255,0.9)')
        }
        .alignItems(HorizontalAlign.Start)

        // ç§»é™¤ä¸å­˜åœ¨çš„app_iconå¼•ç”¨
        Blank().width(48).height(48)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(VerticalAlign.Center)
    }
    .width('100%')
    .padding({
      left: 24,
      right: 24,
      top: 50, // é¿å¼€çŠ¶æ€æ 
      bottom: 24
    })
    // æ¸å˜èƒŒæ™¯
    .linearGradient({
      angle: 135,
      colors: [['#5C7CFF', 0.0], ['#4A65E0', 1.0]]
    })
    .shadow({ radius: 10, color: 'rgba(92, 124, 255, 0.3)', offsetY: 4 })
    .borderRadius({ bottomLeft: 24, bottomRight: 24 })
    .zIndex(10)
  }

  @Builder
  private FloatingToolbar() {
    Row() {
      Button({ type: ButtonType.Circle, stateEffect: true }) {
        Text('+')
          .fontSize(24)
          .fontColor('#5C7CFF')
          .fontWeight(FontWeight.Medium)
          .offset({ y: -1 }) // å¾®è°ƒå±…ä¸­
      }
      .width(40)
      .height(40)
      .backgroundColor('#FFFFFF')
      .shadow({ radius: 8, color: 'rgba(0,0,0,0.1)', offsetY: 2 })
      .onClick(() => this.startNewConversation())
    }
    .width('100%')
    .justifyContent(FlexAlign.End)
    .padding({ right: 20, top: 16 })
    .hitTestBehavior(HitTestMode.Transparent) // è®©ç‚¹å‡»ç©¿é€ç©ºç™½åŒºåŸŸ
  }

  @Builder
  private EmptyPlaceholder() {
    Column({ space: 16 }) {
      // ä½¿ç”¨ç®€å•çš„åœ†å½¢å›¾æ ‡æ›¿ä»£ä¸å­˜åœ¨çš„ic_public_message
      Column() {
        Text('ğŸ’¬')
          .fontSize(40)
          .fontColor('#D1D6E6')
          .opacity(0.8)
      }
      .width(80)
      .height(80)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)

      Column({ space: 6 }) {
        Text('å¼€å¯å¥åº·å’¨è¯¢')
          .fontSize(18)
          .fontWeight(FontWeight.Medium)
          .fontColor('#333333')
        Text('æ‚¨å¯ä»¥æè¿°ç—‡çŠ¶ã€è¯¢é—®å…»ç”Ÿå»ºè®®\næˆ–è§£è¯»ä½“æ£€æŠ¥å‘Š')
          .fontSize(14)
          .fontColor('#999999')
          .textAlign(TextAlign.Center)
          .lineHeight(20)
      }
    }
    .width('100%')
    .margin({ top: 80 })
    .alignItems(HorizontalAlign.Center)
  }

  // å•æ¡æ¶ˆæ¯æ°”æ³¡
  @Builder
  private MessageBubble(msg: ChatMessage) {
    Row() {
      if (msg.from === 'ai') {
        // AI å¤´åƒ - æ”¹ä¸ºè“è‰²èƒŒæ™¯ï¼Œç™½è‰²å›¾æ ‡
        Column() {
          Text('ğŸ¤–')
            .fontSize(20)
            .fontColor('#FFFFFF')
        }
        .width(36)
        .height(36)
        .borderRadius(18)
        .backgroundColor('#5C7CFF') // è“è‰²èƒŒæ™¯
        .margin({ right: 8, top: 0 })
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
        .alignSelf(ItemAlign.Start) // é¡¶éƒ¨å¯¹é½
      }

      Column() {
        Text(msg.text)
          .fontSize(16)
          .lineHeight(24)
          .fontColor(msg.from === 'user' ? '#FFFFFF' : '#333333')
          .padding(14)
          .backgroundColor(msg.from === 'user' ? '#5C7CFF' : '#FFFFFF')
          .borderRadius(msg.from === 'user'
            ? {
              topLeft: 16,
              topRight: 4,
              bottomLeft: 16,
              bottomRight: 16
            }
            : {
              topLeft: 4,
              topRight: 16,
              bottomLeft: 16,
              bottomRight: 16
            })
          .shadow(msg.from === 'ai' ? { radius: 8, color: 'rgba(0,0,0,0.05)', offsetY: 2 } : undefined)
      }
      .constraintSize({ maxWidth: '70%' }) // ç¨å¾®å‡å°æ°”æ³¡æœ€å¤§å®½åº¦ï¼Œç•™å‡ºå¤´åƒç©ºé—´

      if (msg.from === 'user') {
        // ç”¨æˆ·å¤´åƒ - è®¾ç½®ä¸ºå¯è§
        Image($r('app.media.profileIcon')) // ä½¿ç”¨ç°æœ‰çš„ä¸ªäººèµ„æ–™å›¾æ ‡
          .width(36)
          .height(36)
          .borderRadius(18)
          .backgroundColor('#E0E4F5') // é»˜è®¤åº•è‰²
          .margin({ left: 8, top: 0 })
          .objectFit(ImageFit.Cover)
          .alignSelf(ItemAlign.Start)
          .visibility(Visibility.Visible) // âœ… æ˜¾ç¤ºç”¨æˆ·å¤´åƒ
      }
    }
    .width('100%')
    .justifyContent(msg.from === 'user' ? FlexAlign.End : FlexAlign.Start)
    .alignItems(VerticalAlign.Top)
  }

  // åº•éƒ¨è¾“å…¥åŒºåŸŸ
  @Builder
  private InputArea() {
    Column() {
      Row({ space: 12 }) {
        TextInput({
          text: this.inputText,
          placeholder: 'è¯·è¾“å…¥æ‚¨çš„å¥åº·é—®é¢˜...'
        })
          .type(InputType.Normal)
          .placeholderColor('#B0B5C7')
          .fontColor('#333333')
          .fontSize(16)
          .caretColor('#5C7CFF')
          .maxLines(4)
          .height(56) // åˆå§‹é«˜åº¦
          .padding({ left: 16, right: 16 })
          .backgroundColor('#FFFFFF')
          .borderRadius(28)
          .layoutWeight(1)
          .shadow({ radius: 4, color: 'rgba(0,0,0,0.05)', offsetY: 1 })
          .enterKeyType(EnterKeyType.Send)
          .onSubmit(() => this.onSend())
          .onChange((value: string) => {
            this.inputText = value
          })

        // å‘é€æŒ‰é’® - ä¼˜åŒ–æ ·å¼
        Button({ type: ButtonType.Circle, stateEffect: true }) {
          // ä½¿ç”¨ç®€æ´çš„ç®­å¤´ç¬¦å·ä»£æ›¿å›¾ç‰‡
          Text('â†‘')
            .fontSize(24)
            .fontWeight(FontWeight.Bold)
            .fontColor('#FFFFFF')
            .padding({ bottom: 2 }) // å¾®è°ƒä½ç½®
        }
        .width(48)
        .height(48)
        .backgroundColor(this.inputText.trim().length > 0 ? '#5C7CFF' : '#D1D6E6')
        .shadow({
          radius: 6,
          color: this.inputText.trim().length > 0 ? 'rgba(92, 124, 255, 0.4)' : 'transparent',
          offsetY: 2
        })
        .onClick(() => this.onSend())
      }
      .alignItems(VerticalAlign.Bottom) // åº•éƒ¨å¯¹é½ï¼Œé€‚åº”å¤šè¡Œè¾“å…¥
      .padding({
        left: 16,
        right: 16,
        top: 12,
        bottom: 12
      })
    }
    .backgroundColor('#F5F7FA') // ä¸èƒŒæ™¯åŒè‰²
    // é¡¶éƒ¨è¾¹æ¡†çº¿ï¼Œå¯é€‰
    // .border({ width: { top: 1 }, color: '#EEF0F5' }) 
  }

  // ç‚¹å‡» Enter åï¼ŒæŠŠè¾“å…¥å†…å®¹åŠ å…¥èŠå¤©åˆ—è¡¨
  private onSend() {
    const content = this.inputText.trim()
    if (content.length === 0 || this.isThinking) {
      return
    }
    const userMsg: ChatMessage = { id: this.nextId++, from: 'user', text: content }
    this.messages = [...this.messages, userMsg]
    this.persistMessages()
    this.inputText = ''
    this.scrollToLatest()

    this.fetchSmartReply(content)
  }

  // æ™ºèƒ½å›å¤ï¼šä¼˜å…ˆå°è¯•è”ç½‘ï¼Œå¤±è´¥åˆ™ä½¿ç”¨æœ¬åœ°è§„åˆ™
  private async fetchSmartReply(question: string) {
    this.isThinking = true

    try {
      // 1. å°è¯•è”ç½‘è·å–
      let replyText = await HealthAIService.fetchOnlineAnswer(question)

      // 2. å¦‚æœè”ç½‘å¤±è´¥ï¼ˆè¿”å› nullï¼‰ï¼Œåˆ™ä½¿ç”¨ç¦»çº¿å…œåº•
      if (!replyText) {
        // æ¨¡æ‹Ÿä¸€ç‚¹å»¶è¿Ÿï¼Œè®©ä½“éªŒæ›´å¹³æ»‘ï¼Œä¸è‡³äºç¬é—´å¤±è´¥
        await new Promise<void>(resolve => setTimeout(resolve, 600))
        replyText = HealthAIService.buildAnswer(question)
      }

      const aiMsg: ChatMessage = {
        id: this.nextId++,
        from: 'ai',
        text: replyText || 'æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•å›ç­”ã€‚'
      }
      this.messages = [...this.messages, aiMsg]
      this.persistMessages()
    } catch (err) {
      console.error('SmartReply Error:', JSON.stringify(err))
      // å¼‚å¸¸å…œåº•
      const replyText = HealthAIService.buildAnswer(question)
      const aiMsg: ChatMessage = { id: this.nextId++, from: 'ai', text: replyText }
      this.messages = [...this.messages, aiMsg]
      this.persistMessages()
    } finally {
      this.isThinking = false
      this.scrollToLatest()
    }
  }

  @Builder
  private TypingIndicator() {
    Row() {
      // AI å¤´åƒå ä½
      Blank().width(36 + 8)

      Row({ space: 4 }) {
        Circle({ width: 6, height: 6 }).fill('#B0B5C7')
        Circle({ width: 6, height: 6 }).fill('#B0B5C7').opacity(0.7)
        Circle({ width: 6, height: 6 }).fill('#B0B5C7').opacity(0.4)
      }
      .height(36)
      .padding({ left: 16, right: 16 })
      .backgroundColor('#FFFFFF')
      .borderRadius({
        topLeft: 4,
        topRight: 18,
        bottomLeft: 18,
        bottomRight: 18
      })
      .shadow({ radius: 8, color: 'rgba(0,0,0,0.05)', offsetY: 2 })
    }
    .width('100%')
    .justifyContent(FlexAlign.Start)
    .margin({ top: 4, bottom: 4 })
  }

  private scrollToLatest() {
    setTimeout(() => {
      this.chatScroller.scrollTo({
        xOffset: 0,
        yOffset: 100000,
        animation: { duration: 300, curve: Curve.EaseOut }
      })
    }, 100)
  }

  private restoreMessages() {
    (async () => {
      try {
        const pref = await this.ensurePreferences()
        const stored = await pref.get(AskAIPage.HISTORY_KEY, '[]') as string
        const parsed = JSON.parse(stored) as ChatMessage[]
        if (Array.isArray(parsed)) {
          this.messages = parsed
          this.historySnapshot = stored
          this.nextId = parsed.reduce((max, item) => Math.max(max, item.id), 0) + 1
        } else {
          this.resetMemory()
        }
      } catch (err) {
        console.error('restoreMessages failed', JSON.stringify(err))
        this.resetMemory()
      }
    })()
  }

  private persistMessages() {
    const snapshot = JSON.stringify(this.messages)
    this.historySnapshot = snapshot
    ;
    (async () => {
      try {
        const pref = await this.ensurePreferences()
        await pref.put(AskAIPage.HISTORY_KEY, snapshot)
        await pref.flush()
      } catch (err) {
        console.error('persistMessages failed', JSON.stringify(err))
      }
    })()
  }

  private async ensurePreferences(): Promise<dataPreferences.Preferences> {
    if (this.preferences) {
      return this.preferences
    }
    const abilityContext = getContext(this) as common.UIAbilityContext
    this.preferences = await dataPreferences.getPreferences(abilityContext, AskAIPage.PREF_FILE)
    return this.preferences
  }

  private resetMemory() {
    this.messages = []
    this.nextId = 1
    this.historySnapshot = '[]'
  }

  private startNewConversation() {
    this.resetMemory()
    this.persistMessages()
    this.scrollToLatest()
  }
}